import semver from 'semver';

import { VersionIssue } from './semverUtils';

interface GitHubAdvisoryIdentifier {
  type: string;
  value: string;
}

interface GitHubAdvisoryReference {
  url: string;
}

interface GitHubAdvisoryPackage {
  ecosystem: string;
  name: string;
}

interface GitHubAdvisoryVulnerability {
  package: GitHubAdvisoryPackage;
  severity?: string;
  vulnerable_version_range: string;
  first_patched_version?: { identifier?: string | null } | null;
}

interface GitHubAdvisory {
  ghsa_id: string;
  summary: string;
  description?: string;
  severity?: string;
  identifiers?: GitHubAdvisoryIdentifier[];
  references?: GitHubAdvisoryReference[];
  published_at?: string;
  updated_at?: string;
  vulnerabilities?: GitHubAdvisoryVulnerability[];
  permalink?: string;
}

const advisoryCache = new Map<string, GitHubAdvisory[]>();
const GITHUB_ADVISORY_URL = 'https://api.github.com/advisories';
const RECENT_DAYS_THRESHOLD = 180;
const CRITICAL_SEVERITIES = new Set(['HIGH', 'CRITICAL']);

const isRecentPublication = (input?: string): boolean => {
  if (!input) {
    return true;
  }
  const publishedDate = new Date(input).getTime();
  if (Number.isNaN(publishedDate)) {
    return true;
  }
  const now = Date.now();
  const diffDays = (now - publishedDate) / (1000 * 60 * 60 * 24);
  return diffDays <= RECENT_DAYS_THRESHOLD;
};

const isAffectedVersion = (version: string, range: string): boolean => {
  try {
    return semver.satisfies(version, range, { includePrerelease: false });
  } catch (error) {
    console.warn('No se pudo evaluar el rango vulnerable', range, error);
    return false;
  }
};

async function fetchAdvisories(pkgName: string): Promise<GitHubAdvisory[]> {
  if (advisoryCache.has(pkgName)) {
    return advisoryCache.get(pkgName)!;
  }

  try {
    const response = await fetch(
      `${GITHUB_ADVISORY_URL}?ecosystem=npm&package=${encodeURIComponent(pkgName)}&per_page=100`,
    );
    if (!response.ok) {
      throw new Error(`GitHub Advisory API respondió ${response.status}`);
    }
    const data = (await response.json()) as GitHubAdvisory[];
    advisoryCache.set(pkgName, data);
    return data;
  } catch (error) {
    console.error('No se pudo consultar el feed de vulnerabilidades', pkgName, error);
    advisoryCache.set(pkgName, []);
    return [];
  }
}

const toIssueMessage = (
  advisory: GitHubAdvisory,
  vulnerability: GitHubAdvisoryVulnerability,
  version: string,
): VersionIssue => {
  const severity = (vulnerability.severity ?? advisory.severity ?? 'UNKNOWN').toUpperCase();
  const identifiers = advisory.identifiers ?? [];
  const cveIds = identifiers.filter((item) => item.type === 'CVE').map((item) => item.value);
  const label = cveIds.length > 0 ? cveIds.join(', ') : advisory.ghsa_id;
  const summary = advisory.summary?.trim() ?? 'Se registró una vulnerabilidad crítica.';
  const truncatedSummary = summary.length > 140 ? `${summary.slice(0, 137)}...` : summary;
  const fixVersion = vulnerability.first_patched_version?.identifier ?? null;
  const publishedAt = advisory.published_at ?? advisory.updated_at ?? null;
  const publishedLabel = publishedAt ? new Date(publishedAt).toLocaleDateString('es-ES') : null;
  const fixMessage = fixVersion
    ? ` Actualiza a ${fixVersion} o superior para mitigar el riesgo.`
    : ' Aún no hay una versión parche disponible.';
  const meta = publishedLabel ? ` Publicado ${publishedLabel}.` : '';

  return {
    type: 'vulnerable',
    message: `${label} (${severity.toLowerCase()}): ${truncatedSummary}.${fixMessage}${meta}`,
    affectedVersions: [version, vulnerability.vulnerable_version_range],
  };
};

export async function getCriticalVulnerabilityIssues(
  pkgName: string,
  resolvedVersion: string,
): Promise<VersionIssue[]> {
  if (!pkgName || !resolvedVersion || !semver.valid(resolvedVersion)) {
    return [];
  }

  const advisories = await fetchAdvisories(pkgName);
  if (!advisories.length) {
    return [];
  }

  const seen = new Set<string>();
  const issues: VersionIssue[] = [];

  advisories.forEach((advisory) => {
    const vulnerabilities = advisory.vulnerabilities ?? [];
    vulnerabilities.forEach((vulnerability) => {
      const pkg = vulnerability.package;
      const severity = (vulnerability.severity ?? advisory.severity ?? '').toUpperCase();
      if (pkg?.ecosystem !== 'npm' || pkg?.name !== pkgName) {
        return;
      }
      if (!CRITICAL_SEVERITIES.has(severity)) {
        return;
      }
      if (!isRecentPublication(advisory.published_at ?? advisory.updated_at)) {
        return;
      }
      if (!isAffectedVersion(resolvedVersion, vulnerability.vulnerable_version_range)) {
        return;
      }

      const dedupeKey = `${advisory.ghsa_id}:${vulnerability.vulnerable_version_range}`;
      if (seen.has(dedupeKey)) {
        return;
      }
      seen.add(dedupeKey);

      issues.push(toIssueMessage(advisory, vulnerability, resolvedVersion));
    });
  });

  return issues;
}

export function clearAdvisoryCache(): void {
  advisoryCache.clear();
}
